import { orders, type Order, type InsertOrder } from "@shared/schema";
import { nanoid } from "nanoid";
import { db } from "./db";
import { eq, and, between } from "drizzle-orm";

// Define types for statistics
interface StatItem {
  code: string;
  name: string;
  totalQuantity: number;
  orderCount: number;
}

interface OrderStats {
  stats: StatItem[];
  periodText: string;
  totalOrders: number;
}

export interface IStorage {
  getOrders(status?: "temporary" | "completed"): Promise<Order[]>;
  getOrdersByDateRange(startDate: string, endDate: string, status?: "temporary" | "completed"): Promise<Order[]>;
  createOrder(order: InsertOrder): Promise<Order>;
  deleteOrder(id: string): Promise<void>;
  completeOrder(id: string): Promise<Order>;
  generateOrderStats(year: string, month?: string): Promise<OrderStats>;
}

export class DatabaseStorage implements IStorage {
  async getOrders(status?: "temporary" | "completed"): Promise<Order[]> {
    if (status) {
      return db.select().from(orders).where(eq(orders.status, status));
    }
    return db.select().from(orders);
  }

  async getOrdersByDateRange(startDate: string, endDate: string, status?: "temporary" | "completed"): Promise<Order[]> {
    // Build query conditions
    const conditions = [
      between(orders.delivery_date, startDate, endDate)
    ];
    
    // Add status condition if provided
    if (status) {
      conditions.push(eq(orders.status, status));
    }
    
    return db
      .select()
      .from(orders)
      .where(and(...conditions));
  }

  async createOrder(orderData: InsertOrder): Promise<Order> {
    // Insert the order into the database
    const [order] = await db
      .insert(orders)
      .values({
        ...orderData,
        // UUID will be auto-generated by the database
      })
      .returning();
    
    return order;
  }

  async deleteOrder(id: string): Promise<void> {
    // Delete the order from the database
    const [deletedOrder] = await db
      .delete(orders)
      .where(eq(orders.id, id))
      .returning();
    
    if (!deletedOrder) {
      throw new Error(`Order with ID ${id} not found`);
    }
  }

  async completeOrder(id: string): Promise<Order> {
    // Update the order status to completed
    const [updatedOrder] = await db
      .update(orders)
      .set({
        status: "completed",
        completed_at: new Date().toISOString()
      })
      .where(eq(orders.id, id))
      .returning();
    
    if (!updatedOrder) {
      throw new Error(`Order with ID ${id} not found`);
    }
    
    return updatedOrder;
  }

  async generateOrderStats(year: string, month?: string): Promise<OrderStats> {
    // Build date range
    let startDate: string;
    let endDate: string;
    let periodText: string;
    
    if (month) {
      // Specific month
      const monthNum = parseInt(month, 10);
      const paddedMonth = monthNum.toString().padStart(2, '0');
      startDate = `${year}-${paddedMonth}-01`;
      
      // Calculate last day of month
      const lastDay = new Date(parseInt(year), monthNum, 0).getDate();
      endDate = `${year}-${paddedMonth}-${lastDay}`;
      
      periodText = `${year}年${monthNum}月`;
    } else {
      // Entire year
      startDate = `${year}-01-01`;
      endDate = `${year}-12-31`;
      periodText = `${year}年全年`;
    }
    
    // Get completed orders for the date range
    const completedOrders = await this.getOrdersByDateRange(startDate, endDate, "completed");
    
    // Prepare stats
    const productStats: Record<string, StatItem> = {};
    
    // Calculate stats
    completedOrders.forEach(order => {
      if (!productStats[order.product_code]) {
        productStats[order.product_code] = {
          code: order.product_code,
          name: order.product_name,
          totalQuantity: 0,
          orderCount: 0
        };
      }
      
      // Parse quantity as it might be stored as string in some environments
      const quantity = typeof order.quantity === 'string' 
        ? parseFloat(order.quantity.toString()) 
        : Number(order.quantity);
      
      productStats[order.product_code].totalQuantity += quantity;
      productStats[order.product_code].orderCount += 1;
    });
    
    // Convert to array and sort by total quantity (descending)
    const statsArray = Object.values(productStats).sort((a, b) => 
      b.totalQuantity - a.totalQuantity
    );
    
    return {
      stats: statsArray,
      periodText,
      totalOrders: completedOrders.length
    };
  }
}

// Export an instance of the DatabaseStorage
export const storage = new DatabaseStorage();
